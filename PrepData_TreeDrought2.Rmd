---
title: "Prep for tree drought"
author: "WHMackenzie"
date: "2025-05-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(foreach)
require(ggplot2)
require (ggthemes)
require(tidyverse)
require(data.table)
require(climr)
require(tictoc)
```

Prep data for the tree drought model. 
# Sample 100 points from each BGC and add climate data and save to file

```{r import tables, echo=FALSE, message = FALSE, warning=FALSE}
# import grid points attributed to BGC and select a set
coords <- fread("D:/OneDrive - Government of BC/CommonTables/BGCv13_3_2km_gridpts.csv")# %>% dplyr::select(-BGC)
coords <- coords %>%
  group_by(BGC) %>%
  sample_n(100, replace = TRUE) %>% ungroup %>% 
  rename(lon = xcoord, lat = ycoord)
count_tp <- coords %>% dplyr::count(BGC)
coords_sf <- st_as_sf(coords, coords = c("lon","lat"), crs = 4326)
coords <- as.data.frame(coords) %>% distinct
setcolorder(coords, c("lat", "lon","elev","id"))
coords.bgc <- coords %>% dplyr::select(id, BGC, lon,lat,elev)
## download climr data
tic()
clim_vars <- climr::downscale(setDT(coords),
                              vars = list_vars(),
                              return_refperiod = TRUE,
                              obs_periods = c("2001_2020"),
                              obs_years = 2001:2024,
                              #obs_ts_dataset = "cru.gpcc",
                              obs_ts_dataset = "mswx.blend",
                              cache = TRUE,
                              db_option = "local")

allDat <- left_join(coords.bgc, clim_vars) %>% as.data.table
fwrite(allDat, "./inputs/BGC_climate_periods.csv")

CMDtemp <- allDat %>% select("CMD", "CMD_08")
AllBGC <- unique(allDat$BGC) %>% data.frame() %>% pull()

## ID BGCs with consistent summer precipitation = less drought prone on drier rSMR than expected
## Especially to fix hypermartime
sPPTtemp <- allDat %>% select("BGC", "PERIOD", "PPT_05","PPT_06","PPT_07","PPT_08","PPT_09" )
sPPTtemp$Moist <- rowSums(sPPTtemp[,3:7] >90) #count of growing season months with >90mm rain
ratio.moist <- sPPTtemp %>% select(BGC, PERIOD, Moist) %>% group_by (BGC, PERIOD) %>% summarize (count= length(BGC), moistcount = length(BGC[Moist == 5]), ratio = moistcount/count)
sPPTtemp$Moist <- ifelse(sPPTtemp$Moist > 4, 1, 0) # flag locations where all months are >90mm rain. If all months then always overcapacity zonal soils
                     # ifelse(temp2$Moist >3, 5.5,""))
sPPTtemp <- sPPTtemp %>% select("BGC", "PERIOD", "Moist")
moist.multiply <- ratio.moist %>% select(BGC, PERIOD, ratio) %>% mutate(multiplier = 1+ratio) %>% data.table
#allDat[moist.multiply, CMD := CMD / multiplier, on = "BGC"]

wPPTtemp <- allDat[,c("BGC", "PERIOD", "PPT_at","PPT_wt","PAS")]
allDat2 <- cbind(wPPTtemp,CMDtemp)
#allDat <- cbind(wPPTtemp,sPPTtemp[c("Moist")])
#allDat <- cbind(allDat,temp,temp2) ### use this one if Moist indicator is completed above
allDat2$PPT.dorm <- allDat2$PPT_at + allDat2$PPT_wt
  ####To adjust in zones with prolonged snowpack remove CMD from early growing season months
## BGCs with or below heavy snow packs
BGC_Special <- fread("./inputs/BGC_Special.csv", data.table = FALSE)
allDat2 <- left_join(allDat2,BGC_Special, by = c("BGC" = "BGC"))
allDat2 <- allDat2 %>% mutate(CMD = ifelse(is.na(Special), CMD, CMD_08)) %>% select(-Special, -CMD_08) %>% drop_na()

##-----Start of Growing season deficits 
###adds deficit from incomplete recharge in dormant season. Estimated holding capacity of loamy soils is approximately 350mm.
## 500m might be a better fit - approximates the extreme years
allDat2 <- allDat2[,c("BGC", "PERIOD", "CMD","PPT.dorm")]
allDat2$Def <- 350 - allDat2$PPT.dorm 
allDat2$Def[allDat2$Def < 0] <- 0 #negative values set to zero = no deficit
allDat2$CMD <- allDat2$CMD + allDat2$Def
allDat2 <- allDat2[,c("BGC", "PERIOD", "CMD")]

CMD <- allDat2 %>%
  group_by(BGC, PERIOD) %>%
  summarize(across(everything(), median)) %>% ungroup# CMD now equals CMD.total
    CMD <- CMD %>% mutate(CMD.hot = CMD * 1.25) # 25% increase in CMD for insolation slopes (from Jackson 1966)
    CMD <- CMD %>% mutate(CMD.cold = CMD * 0.85)
```

``` {r create tables, echo=FALSE, message = FALSE, warning=FALSE}

#period = "1961_1990"; cmd.type = "CMD"
create_cmd_rsmr_grid <- function(cmd, cmd.type, period, AllBGC) {
  # Filter by PERIOD
  CMD <- cmd %>% filter(PERIOD == period) %>% select(BGC, all_of(cmd.type))
  
  # Compute wetter rSMR values
  for (i in 1:3) {
    CMD[, 2 + i] <- CMD[, 1 + i] / 2
  }

  # Rename columns
  colnames(CMD) <- c("BGC", "rSMR4", "rSMR5", "rSMR6", "rSMR7")
  CMD <- CMD[, c("BGC", "rSMR7", "rSMR6", "rSMR5", "rSMR4")]
  # Compute drier rSMR values
  for (i in 1:4) {
    CMD[, length(CMD) + 1] <- CMD[, length(CMD)] + 125
  }

  # Rename newly added columns
  colnames(CMD)[6:9] <- c("rSMR3", "rSMR2", "rSMR1", "rSMR0")

  # Reorder columns
  CMD <- CMD[, c("BGC", "rSMR7", "rSMR6", "rSMR5", "rSMR4", "rSMR3", "rSMR2", "rSMR1", "rSMR0")]

  # Filter by specified BGCs
  CMD <- CMD %>% filter(BGC %in% AllBGC)

  # Add cmd.type and period identifiers
  CMD$cmd.type <- cmd.type
  CMD$PERIOD <- period

  return(CMD)
}

# Define cmd.types and extract unique PERIOD values
cmd_types <- c("CMD", "CMD.hot", "CMD.cold")
periods <- unique(CMD$PERIOD)

# Create all combinations of cmd.type and PERIOD
cmd_grid <- expand.grid(cmd_types, periods, stringsAsFactors = FALSE)
colnames(cmd_grid) <- c("cmd_type", "period")

# Apply function iteratively
rsmr_cmd_list <- pmap(cmd_grid, ~ create_cmd_rsmr_grid(CMD, .x, .y, AllBGC))

# Combine results
rsmr_cmd <- bind_rows(rsmr_cmd_list)

# Convert to long format
rsmr_cmd_long <- rsmr_cmd %>%
  pivot_longer(cols = -c("BGC", "cmd.type", "PERIOD"), names_to = "rSMR", values_to = "CMD.site") %>%
  ungroup() %>%
  data.table()# %>%
  #select(-cmd.type)
rsmr_cmd_long[moist.multiply, CMD.site := CMD.site / multiplier, on = c("BGC", "PERIOD")]
xx <- rsmr_cmd_long %>% filter(BGC =="MHvh")
# Save as CSV if needed
fwrite(rsmr_cmd_long, file = "./outputs/CMD_by_rSMR_long_with_periods.csv")

rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v13_23June2025.csv")
rsmr_asmr_long <- rsmr_cmd_long %>%
  left_join(rules, by = "rSMR") %>%
  filter(CMD.site <= CMD) %>%
  group_by(BGC, PERIOD, rSMR, cmd.type) %>%  # ensure row-wise logic if needed
  slice_max(aSMR, with_ties = FALSE) %>%
  ungroup() %>% select(BGC, PERIOD, rSMR, aSMR, cmd.type)
fwrite(rsmr_asmr_long, file = "./outputs/modelled_aSMR_by_rSMR_long.csv")# saved file used drought_prone_site.qmd
# all_cmd <- rsmr_asmr_long   %>%
#   arrange(BGC) %>%
#   pivot_wider(names_from = rSMR, values_from = aSMR)
#fwrite (all_cmd, "./outputs/CMDcalc_aSMR_by_rSMR_matrix.csv")

```

----Old Code-----


```{r}
# rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v12_31Oct2024.csv")
# #rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v12_1May2025.csv")
# BGC.rain <- fread("./inputs/Coast_freq_rain_BGCs.csv") %>% filter(freq_rain %in% "y") %>% pull(bgc)
# aSMRClass <- function(x) {
#   for (i in seq_along(ruleSelect$CMD)) {
#     if (i < length(ruleSelect$CMD) && x <= ruleSelect$CMD[i+1]) {
#       return(ruleSelect$aSMR[i])
#     }
#   }
#   return(x)
# }
# # Initialize an empty data.frame to accumulate results
# all_asmr <- data.frame()
# cmd.type <- "CMD.cold"
# rsmr.cmd <- rsmr.cmd.cold  %>% as.data.frame
# CMD <- rsmr.cmd  %>% as.data.frame %>% select(-cmd.type)
# i=1
# for (i in seq_along(CMD$BGC)) {
#   CMD.bgc <- CMD[i,]
#   test <- foreach(SMR = colnames(CMD.bgc)[-1], .combine = cbind) %do% {
#     temp <- CMD.bgc %>% select(!!as.name(SMR))
#     temp[is.na(temp)] <- 0
#     
#     if (SMR == "rSMR7") {
#       ruleSelect <- rules[rules$SMRLevel == 7, -1]
#     } else if (SMR == "rSMR6") {
#       ruleSelect <- rules[rules$SMRLevel == 6, -1]
#     } else if (SMR == "rSMR5") {
#       ruleSelect <- rules[rules$SMRLevel == 5, -1]
#     } else {
#       ruleSelect <- rules[rules$SMRLevel == 0, -1]
#     }
#     
#     out <- sapply(temp, FUN = aSMRClass)
#     out
#   }
# 
#   bgc <- as.data.frame(test)
#   row.names(bgc) <- CMD.bgc$BGC
#   colnames(bgc) <- c("rSMR0", "rSMR1", "rSMR2", "rSMR3", "rSMR4", "rSMR5", "rSMR6", "rSMR7")
#   
#   # Accumulate the test data into all_tests
#   all_asmr <- rbind(all_asmr, bgc)
# }
# all_asmr <- all_asmr %>% rownames_to_column(var = "BGC")
# #fwrite (all_asmr, "./outputs/CMDcalc_aSMR_by_rSMR_matrix.csv")
# rsmr_asmr.long <- all_asmr %>% pivot_longer(cols = -"BGC", names_to = "rSMR", values_to = "aSMR") %>% ungroup %>%  data.table
# rsmr_asmr.long2 <- merge(rsmr_asmr.long, rsmr_cmd.cold.long, by = c("BGC", "rSMR"))%>% mutate(cmd.type = cmd.type) 
# 
# fwrite(rsmr_asmr.long2, file = paste0("./outputs/", cmd.type, "aSMR_by_rSMR_long.csv"))
```


```{r}
# CMD.long <- fread("./outputs/CMDaSMR_by_rSMR_long.csv")
# CMD.hot.long <- fread("./outputs/CMD.hotaSMR_by_rSMR_long.csv")
# CMD.cold.long <- fread("./outputs/CMD.coldaSMR_by_rSMR_long.csv")
# CMD.long <- bind_rows(CMD.long, CMD.hot.long, CMD.cold.long)
# fwrite(CMD.long, "./outputs/aSMR_by_rSMR_long.csv")
```

```{r build tables, echo=FALSE, message = FALSE, warning=FALSE}
# rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v12_31Oct2024.csv")
# #rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v12_1May2025.csv")
# BGC.rain <- fread("./inputs/Coast_freq_rain_BGCs.csv") %>% filter(freq_rain %in% "y") %>% pull(bgc)
# aSMRClass <- function(x) {
#   for (i in seq_along(ruleSelect$CMD)) {
#     if (i < length(ruleSelect$CMD) && x <= ruleSelect$CMD[i+1]) {
#       return(ruleSelect$aSMR[i])
#     }
#   }
#   return(x)
# }
# 
# # Initialize an empty data.frame to accumulate results
# all_asmr <- data.frame()
# #i=1
# for (i in seq_along(CMD$BGC)) {
#   CMD.bgc <- CMD[i,]
#   test <- foreach(SMR = colnames(CMD.bgc)[-1], .combine = cbind) %do% {
#     temp <- CMD.bgc %>% select(!!as.name(SMR))
#     temp[is.na(temp)] <- 0
#     
#     if (SMR == "rSMR7") {
#       ruleSelect <- rules[rules$SMRLevel == 7, -1]
#     } else if (SMR == "rSMR6") {
#       ruleSelect <- rules[rules$SMRLevel == 6, -1]
#     } else if (SMR == "rSMR5") {
#       ruleSelect <- rules[rules$SMRLevel == 5, -1]
#     } else {
#       ruleSelect <- rules[rules$SMRLevel == 0, -1]
#     }
#     
#     out <- sapply(temp, FUN = aSMRClass)
#     out
#   }
#   
#   bgc <- as.data.frame(test)
#   row.names(bgc) <- CMD.bgc$BGC
#   colnames(bgc) <- c("rSMR0", "rSMR1", "rSMR2", "rSMR3", "rSMR4", "rSMR5", "rSMR6", "rSMR7")
#   
#   # Accumulate the test data into all_tests
#   all_asmr <- rbind(all_asmr, bgc)
# }
# all_asmr <- all_asmr %>% rownames_to_column(var = "BGC")
# fwrite (all_asmr, "./outputs/CMDcalc_aSMR_by_rSMR_matrix.csv")
# 
# rsmr_asmr.long <- all_asmr %>% pivot_longer(cols = -"BGC", names_to = "rSMR", values_to = "aSMR") %>% ungroup %>%  data.table
# rsmr_asmr.long2 <- merge(rsmr_asmr.long, rsmr_cmd.long, by = c("BGC", "rSMR")) %>% mutate(cmd.type = cmd.type) 
# fwrite(rsmr_asmr.long2, file = "./outputs/aSMR_by_rSMR_long.csv")
```

