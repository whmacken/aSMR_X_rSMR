---
title: "Building an aSMR for rSMR matrix from Climate Moisture Deficit"
author: "William H MacKenzie"
date: "31/10/2024"
format:
  typst:
    toc: false
    toc-depth: 1
    toc-title: Contents
    section-numbering: 1.1.1
    columns: 1
editor: source
execute:
  echo: false
  error: false
  warning: false
  message: false
  fig.width: 6
  fig.height: 4
  fig.align: 'center'
  fig.cap: true
  fig.pos: H
  out.width: '100%'
  dev: pdf
  fig.ext: pdf
  cache: false
  fig.retina: 2
  dpi: 600
  fig.asp: 1.5
  fig.path: "./figures/"
---

```{r setup, include=FALSE}
require(foreach)
require(ggplot2)
require (ggthemes)
require(tidyverse)
require(data.table)
require(sf)
require(climr)
require(ggrepel)
require(tictoc)

```

# Introduction

The biogeoclimatic ecosystem classification (BEC) system uses relative soil moisture and nutrient regime to frame environmental differences between site series within an area of similar regional climate (biogeoclimatic subzone/variants). Relative soil moisture regime classes are defined from site and soils characteristics into nine classes representing an ordinal ranking of site conditions from the driest site conditions (very xeric: rSMR 0) to the wettest terrestrial conditions on the landscape (hydric: rSMR 8). The assessment of rSMR is independent of the regional climate: the site conditions describing xeric site is the same in all biogeoclimatic units (BGCs). This feature allows ecological characteristics of different BGCs to be compared aligning similar site and soils conditions. The site and soils conditions describing mesic relative soil moistures (rSMR 4) (and mesotrophic nutrient status) are considered to be those sites that best reflect regional climatic conditions and are said to be the **zonal site**. The mature ecosystem that occupies this relative position in a BGC is the zonal ecosystem and the differences in vegetation composition of zonal ecosystems used to differentiate and relate biogeoclimatic units.

However for some purposes, such as defining the water balance relationships for a species, the actual soil moisture regime, instead of the relative is required. Direct quantitative measurement of ecologically important soil moisture requires multi-year and multi-depth monitoring to be effective. Due to technological and cost limitations few studies have been undertaken to quantify soil moisture status of site series. With the high diversity of climatic and site conditions in the province quantitative measurement across even a representative set of environmental and ecosystem conditions is untenable. In response to this challenge, Klinka (1989;2000) proposed a classification system for defining actual soil moisture regime based broader approximations on the ratio of actual to potential evaporation and the number of months in deficit. {insert table} Regional Ecologists created a rSMR x aSMR grid for all mapped BGCs in 1990 using Klinka's first approximation (1989). This matrix was built primarily through interpretation of the actual soil moisture indicator status of the plant species occurring on each rSMR position. Some variation in the interpretation of this plant community - soil moisture relationship between experts and regions occurred and the matrix only applies to 129 of the 221 currently recognized biogeoclimatic units.

The aSMR of a site is a function of climatic precipitation inputs, soil water-holding capacity, and non-climatic soil water inputs often approximated by slope position.

This script represents a process to both complete the rSMR x aSMR matrix for all contemporary BGCs and provide a objective comparison between expert assigned aSMR ranking using regional climatic moisture deficit from the climr climate surface. The CMD model heuristically defines ranges of CMD that match expert aSMR categories for rSMR 4 (zonal) conditions and then creates a CMD adjustment for each azonal rSMR optimized to match the values from the expert grid. Draft work to create a species indicator value by rSMR as a check of these expert ratings proposed.

The ForDRAT drought tool generates aSMR classes from an approximation of Craig Nitchke's drought equations. We compare CMD-aSMR ratings to those from ForDRAT.

`#show figure: set block(breakable: true)`{=typst}

# Determine range of Climatic Moisture Deficit bracketing Expert Assigned aSMR Class of Zonal Sites

The development of a seamless climate surface for British Columbia presented an opportunity for linking aSMR as defined by AET/PET ratio to the climate moisture deficit (CMD). Since the zonal site is thought to best reflect climatic conditions a comparison of the CMD range representing each of the aSMR classes as defined in the 1990 expert grid (with some modern updates) was used to define some initial CMD ranges that represent each class. Errors in aSMR assignment and in the Climate Surface are both likely but in aggregate believed to be generally accurate.

::: {style="font-size: 80%; width=4in; margin-left: 2in; margin-right: 2in; margin-top: 0.5in; margin-bottom: 0.5in;"}
| aSMR Value | aSMR code | aSMR name       |
|------------|-----------|-----------------|
| 0          | XD        | Extremely dry   |
| 1          | ED        | Excessively dry |
| 2          | VD        | Very dry        |
| 3          | MD        | Moderately dry  |
| 4          | SD        | Slightly Dry    |
| 5          | F         | Fresh           |
| 6          | M         | Moist           |
| 7          | VM        | Very Moist      |
| 8          | W         | Wet             |

: aSMR values to aSMR categories
:::

```{r prepare data, echo=FALSE, message = FALSE, warning=FALSE}
# import grid points attributed to BGC and select a set
coords <- fread("D:/OneDrive - Government of BC/CommonTables/BGCv13_3_2km_gridpts.csv")# %>% dplyr::select(-BGC)
coords <- coords %>%
  group_by(BGC) %>%
  sample_n(100, replace = TRUE) %>% ungroup %>% 
  rename(lon = xcoord, lat = ycoord)
count_tp <- coords %>% dplyr::count(BGC)
coords_sf <- st_as_sf(coords, coords = c("lon","lat"), crs = 4326)
coords <- as.data.frame(coords) %>% distinct
setcolorder(coords, c("lat", "lon","elev","id"))
coords.bgc <- coords %>% dplyr::select(id, BGC, lon,lat,elev)
## download climr data
tic()
clim_vars <- climr::downscale(setDT(coords),  
                              vars = list_vars(), 
                              return_refperiod = TRUE, 
                              cache = TRUE)

allDat <- left_join(coords.bgc, clim_vars) %>% as.data.table

CMDtemp <- allDat %>% select("CMD", "CMD_08")
AllBGC <- unique(allDat$BGC) %>% data.frame() %>% pull()

## ID BGCs with consistent summer precipitation = less drought prone on drier rSMR than expected
## Especially to fix hypermartime
sPPTtemp <- allDat %>% select("BGC", "PPT_05","PPT_06","PPT_07","PPT_08","PPT_09" )
sPPTtemp$Moist <- rowSums(sPPTtemp[,2:6] >90) #count of growing season months with >90mm rain
ratio.moist <- sPPTtemp %>% select(BGC,Moist) %>% group_by (BGC) %>% summarize (count= length(BGC), moistcount = length(BGC[Moist == 5]), ratio = moistcount/count)
sPPTtemp$Moist <- ifelse(sPPTtemp$Moist > 4, 1, 0) # flag locations where all months are >90mm rain. If all months then always overcapacity zonal soils
                     # ifelse(temp2$Moist >3, 5.5,""))
sPPTtemp <- sPPTtemp %>% select("BGC","Moist")
moist.multiply <- ratio.moist %>% select(BGC, ratio) %>% mutate(multiplier = 1+ratio) %>% data.table
#allDat[moist.multiply, CMD := CMD / multiplier, on = "BGC"]

wPPTtemp <- allDat[,c("BGC","PPT_at","PPT_wt","PAS")]
allDat2 <- cbind(wPPTtemp,CMDtemp)
#allDat <- cbind(wPPTtemp,sPPTtemp[c("Moist")])
#allDat <- cbind(allDat,temp,temp2) ### use this one if Moist indicator is completed above
allDat2$PPT.dorm <- allDat2$PPT_at + allDat2$PPT_wt
 cmd <- aggregate( . ~ BGC, allDat2, mean)

  ####To adjust in zones with prolonged snowpack remove CMD from early growing season months
## BGCs with or below heavy snow packs
BGC_Special <- fread("./inputs/BGC_Special.csv", data.table = FALSE)
cmd <- full_join(cmd,BGC_Special, by = c("BGC" = "BGC"))
cmd <- cmd %>% mutate(CMD = ifelse(is.na(Special), CMD, CMD_08)) %>% select(-Special, -CMD_08) %>% drop_na()

##-----Start of Growing season deficits 
###adds deficit from incomplete recharge in dormant season. Estimated holding capacity of loamy soils is approximately 350mm.
## 500m might be a better fit - approximates the extreme years
cmd <- cmd[,c("BGC","CMD","PPT.dorm")]
cmd$Def <- 350 - cmd$PPT.dorm 
cmd$Def[cmd$Def < 0] <- 0 #negative values set to zero = no deficit
cmd$CMD <- cmd$CMD + cmd$Def
CMD <- cmd[,c("BGC","CMD")] # CMD now equals CMD.total

###for each wetter rSMR, previous CMD is divided by 2
for (i in 1:3){
  CMD[,2+i] <- CMD[,1+i]/2
}
colnames(CMD) <- c("BGC","rSMR4","rSMR5","rSMR6","rSMR7")
CMD <- CMD[,c(1,3:5,2)]

###for each drier rSMR, previous CMD + 125
for (i in 1:4) {
  #CMD[[length(CMD) + 1]] <- CMD[[length(CMD)]] + pmin((CMD[[length(CMD)]]*2), 125)
  CMD[, length(CMD) + 1] <- CMD[, length(CMD)] + 125
}

colnames(CMD)[6:9] <- c("rSMR3","rSMR2","rSMR1","rSMR0")
CMD <- CMD[,order(colnames(CMD))]## creates full grid of CMD values by BGC by rSMR class
CMD <- CMD %>% filter(BGC %in% AllBGC) ## only those BGCs in the modelled set
write.csv (CMD, "./outputs/CMD_by_rSMR_matrix.csv")

rsmr_cmd.long <- CMD %>% pivot_longer(cols = -"BGC", names_to = "rSMR", values_to = "CMD") %>% left_join(moist.multiply, by = "BGC") %>% mutate(CMD = CMD / multiplier) %>%
  mutate(CMD = round(CMD, -1))

fwrite(rsmr_cmd.long, file = "./outputs/meanCMD_by_rSMR_long.csv")
## add in aSMR class from rule set
rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v13_23June2025.csv")
rsmr_asmr.long <- rsmr_cmd.long %>%
  left_join(rules, by = "rSMR") %>%
  filter(CMD.x <= CMD.y) %>%
  group_by(BGC, rSMR) %>%  # ensure row-wise logic if needed
  slice_max(aSMR, with_ties = FALSE) %>%
  ungroup() %>% select(BGC, rSMR, aSMR)
fwrite(rsmr_asmr.long, file = "./outputs/aSMR_by_rSMR_long.csv")# for use in droughtprone sites
all_cmd <- rsmr_asmr.long   %>%
  arrange(BGC) %>%
  pivot_wider(names_from = rSMR, values_from = aSMR)
fwrite (all_cmd, "./outputs/CMDcalc_aSMR_by_rSMR_matrix.csv")
```

```{r }
#| label: fig-zonal-cmd-ranges
#| fig-cap: "CMD ranges for Expert aSMR of Zonal sites"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"

expGrid <- read.csv("./inputs/ExpertGrid_2025.csv") %>% filter(new.old != "old") %>% select(-new.old)
expGrid$BGC <- gsub("[[:space:]]","",expGrid$BGC)
colnames(expGrid)[-1] <- paste(colnames(expGrid)[-1],"_Exp", sep = "")
CMD.zonal <- CMD %>% select(BGC, rSMR4)
expGrid.zonal <- expGrid %>% select(BGC, rSMR4_Exp) %>% mutate(rSMR4_Exp= as.factor(rSMR4_Exp))
CMDrange <- left_join(expGrid.zonal, CMD.zonal,  by = "BGC")
#CMDrange$rSMR4_Exp <- as.factor(CMDrange$rSMR4_Exp)
#CMDrange$BGC <- as.factor(CMDrange$BGC)

ggplot(CMDrange, aes(rSMR4_Exp, rSMR4)) +
  geom_boxplot(stat = "boxplot", varwidth = TRUE) +
  geom_point(shape = 23, fill = "red", size = 2) +
  xlab("aSMR Class of rSMR4 (zonal) sites") +
  ylab("CMD.total") +
  ggrepel::geom_text_repel(aes(label = BGC), size = 2, maxoverlaps = 103)
#
# ggsave("./outputs/CMD_ranges of Expert aSMR of Zonal.pdf", plot = p, dpi = "print", device = "pdf", width = 15, height = 15, units = "cm")
# ggsave("./outputs/CMD_ranges.png", plot = p, dpi = "print", device = "png", width = 15, height = 15, units = "cm")
# plot(p)


```

### Modelled Range of Climatic Moisture Deficit for aSMR Class of Zonal Sites

With review of the expert ranges a standardized range of CMD for each 1/2 aSMR class was assigned. We estimate aSMR in 1/2 class steps to allow better integration with the rSMR scale on edatopic grids. Regional CMD was modified in some cases where BGCs have: consistent summer precipitation leading to less drought on xeric sites (e.g. hypermaritime); incomplete winter recharge of water table (e.g. BG, PP, driest IDF); or BGCs that occur below higher elevation subzones with very deep snowpacks (e.g. ICHvk, vc, SBSvk). The modelled aSMR classes were then compared to the expert aSMR classes for the zonal sites and the step differences counted. Heuristically the ranges were adjusted to minimize discrepancy from the expert assigned values.

```{r }
#| label: fig-zonal-cmd-ranges-model-coast
#| fig-cap: "CMD ranges for modelled aSMR of coastal Zonal sites"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"
zonal_asmr <- all_cmd %>% select(BGC, rSMR4) %>% rename(aSMR = rSMR4)
zonal_CMD <- CMD %>% select(BGC, rSMR4)
CMDrange <- left_join(zonal_CMD, zonal_asmr, by = c("BGC"))
#CMDrange$rSMR4 <- as.factor(CMDrange$rSMR4)
CMDrange$aSMR <- as.factor(CMDrange$aSMR)
## split in coast and interior
CMD.coast <- CMDrange %>% filter(grepl("^(CDF|CMA|CWH|MH|IDFww|ICHun|ESSFun1|MSun)", BGC))
CMD.interior <- CMDrange %>% filter(grepl("^(BG|IDF|ICH|MS|SBS|SBPS)", BGC))

CMDrange_reduced <- CMDrange %>%  arrange(aSMR) %>%
  group_by(aSMR) %>%
  slice_sample(n = 7) %>%
  ungroup()
ggplot(CMD.coast, aes(x = aSMR, y = rSMR4)) +
  geom_boxplot(stat = "boxplot", varwidth = TRUE) +
  geom_point(shape = 23, fill = "red", size = 2) +
  geom_hline(yintercept = seq(0, max(CMDrange$rSMR4, na.rm = TRUE), by = 100),
             color = "gray80", linetype = "dashed") +
  xlab("aSMR Class of coastal rSMR4 (zonal) sites") +
  ylab("CMD.total") +
  geom_text_repel(aes(label = BGC),
                size = 2,
                #direction = "x", 
                box.padding = 0.1,
                max.overlaps = Inf)+

  # geom_text(aes(label = BGC), size = 2, hjust = -0.5,
  #           position = position_dodge(width = 5))+
  theme_few()
```

```{r }
#| label: fig-zonal-cmd-ranges-model-interior
#| fig-cap: "CMD ranges for modelled aSMR of interior Zonal sites"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"

ggplot(CMD.interior, aes(x = aSMR, y = rSMR4)) +
  geom_boxplot(stat = "boxplot", varwidth = TRUE) +
  geom_point(shape = 23, fill = "red", size = 2) +
  geom_hline(yintercept = seq(0, max(CMDrange$rSMR4, na.rm = TRUE), by = 100),
             color = "gray80", linetype = "dashed") +
  xlab("aSMR Class of interior rSMR4 (zonal) sites") +
  ylab("CMD.total") +
  geom_text_repel(aes(label = BGC),
                size = 2,
                #direction = "x", 
                box.padding = 0.1,
                max.overlaps = Inf)+

  # geom_text(aes(label = BGC), size = 2, hjust = -0.5,
  #           position = position_dodge(width = 5))+
  theme_few()
# ggsave("./outputs/CMD_ranges of Expert aSMR of Zonal.pdf", plot = p, dpi = "print", device = "pdf", width = 15, height = 15, units = "cm")
# ggsave("./outputs/CMD_ranges.png", plot = p, dpi = "print", device = "png", width = 15, height = 15, units = "cm")


```

### Comparison between CMD modelled and expert aSMR for ZONAL sites

The difference in aSMR class between the model and the expert grid are calculated for limited list of 136 BGCs found in the expert matrix.
Since the original expert grid does not apply half classes, many 1/2 class mismatches should be expected and we view these as non-significant differences in assessment.
13 out of 136 BGCs have a difference >=1 aSMR class between the model and expert grid (8 are wetter and 5 are drier). 

```{r }
# expGrid <- read.csv("./inputs/ExpertGrid_2025.csv") %>% filter(new.old != "old") %>% select(-new.old)
# expGrid$BGC <- gsub("[[:space:]]","",expGrid$BGC)
expGrid.zonal <- expGrid %>% select(BGC, rSMR4_Exp)
compare.zonal <- left_join(expGrid.zonal, zonal_asmr,  by = "BGC") %>% 
  mutate(rSMR4_Exp = as.numeric(rSMR4_Exp)) %>%
  mutate(asmr.diff = aSMR - rSMR4_Exp) %>%
  mutate(not.sig.diff = between(asmr.diff, -0.5, .5)) %>%
  mutate(asmr.diff = as.factor(asmr.diff)) %>%
  mutate(Zone = gsub("[^A-Z]", "", BGC)) %>% drop_na()
diff <- compare.zonal %>% count(asmr.diff)
sig.diff <- compare.zonal %>% filter(not.sig.diff == FALSE) %>% select(-not.sig.diff, Zone) 
gt::gt(diff) %>%
  gt::tab_header(
    title = "Count of difference between aSMR from CMD model and Expert aSMR for Zonal Sites",
    subtitle = "CMD aSMR is drier (negative) or wetter (positive) than expert aSMR"
  ) %>%
  gt::tab_options(
    table.font.size = "small",        # options: xx-small to xx-large, or numeric like "80%"
    data_row.padding = gt::px(2),         # tighter spacing between rows
    heading.title.font.size = gt::px(14)  # tweak the title size separately if desired
  )
```

The signicant mismatches are for subzone/variants in the BG  (5 wetter), BWBS (2 drier), CWH (1 drier), 3 ESSF (1 drier and 2 wetter), and IDF (1 wetter). Review of these BGCs suggests that the modelled aSMR may be more representative than the expert assessment in these cases. For the BG units, rSMR4 was aSMR 1 and rSMR5 was aSMR 4; a 3 step jump, which seems problematic.  
```{r }
gt::gt(sig.diff) %>%
  gt::tab_header(
    title = "BGCs with significant difference in aSMR from CMD model and Expert aSMR for Zonal Sites",
    subtitle = "CMD aSMR is drier (negative) or wetter (positive) than expert aSMR"
  ) %>%
  gt::tab_options(
    table.font.size = "small",        # options: xx-small to xx-large, or numeric like "80%"
    data_row.padding = gt::px(2),         # tighter spacing between rows
    heading.title.font.size = gt::px(14)  # tweak the title size separately if desired
  )
```

```{r }
#| label: fig-difference-cmdasmr-expert
#| fig-cap: "aSMR Classes from CMD Model compared to expert assessment"
#| fig-subcap: "CMD is drier (negative) or wetter (positive)"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"
# colnames(rSMRListexp) <- c("BGC", "rSMR", "aSMRE")
# # Loop through unique BGC values and generate individual plots
#  unique_zones <- unique(compare.zonal$Zone)
# 
# for (zone in unique_zones) {
#   # Filter dataset for the current BGC
#   aSMRdiff_subset <- compare.zonal %>% filter(Zone == zone)
#   
#   # Create the histogram
#   asmr.plot <- ggplot(aSMRdiff_subset, aes(asmr.diff, fill = not.sig.diff)) +
#     geom_bar() +
#     #facet_wrap(~ variable, nrow = 2) +
#     geom_vline(xintercept = 0, colour = "green") +
#     xlab("Difference in aSMR Classes") +
#     ylab("Count") +
#       scale_fill_manual(values = c("TRUE" = "green", "FALSE" = "orange")) +
#     theme_hc() +
#     ggtitle(paste0("Histogram of aSMR Differences for ", zone))
#   plot(asmr.plot)
#   # Save each plot as an image file
#   #ggsave(filename = paste0("aSMRdiff_", zone, ".png"), plot = plot, width = 8, height = 6)
# }
# plot(dr)
# ggsave("./outputs/aSMR difference expert_climate by rSMR.pdf", plot = dr, dpi = "print", device = "pdf", width = 15, height = 15, units = "in")
# dev.off()
#gt::gt(compare.zonal)
```

# Compare aSMR across all rSMR

Regional CMD values are adjusted for azonal rSMR positions. For each rSMR step drier add 125 CMD. For each step wetter than zonal divide by two. This adjustment factor was made heuristically to most closely match the expert grid. The range of values representing an aSMR class remain unchanged for rSMR 0-4. For sites that accumulate moisture due to slope position or other seepage, the range of CMD is shifted 1/2 step wetter with each rSMR. For example 150 CMD represents the uppder limite for aSMR 5 (fresh) in rSMR 0-4 positions, aSMR 5.5 for rSMR5, aSMR 6 for rSMR6, and aSMR 6.5 for rSMR7.

```{r }


expGrid <- read.csv("./inputs/ExpertGrid_2025.csv") %>% filter(new.old != "old") %>% select(-new.old)
expGrid$BGC <- gsub("[[:space:]]","",expGrid$BGC)
colnames(expGrid)[-1] <- paste(colnames(expGrid)[-1],"_Exp", sep = "")
CMDrange <- merge(CMD, expGrid, by = "BGC")
CMDrange$rSMR4_Exp <- as.factor(CMDrange$rSMR4_Exp)
CMDrange$BGC <- as.factor(CMDrange$BGC)
exp.asmr <- expGrid %>% filter(BGC %in% all_cmd$BGC) %>% data.table
cmd.asmr <- all_cmd %>% filter(BGC %in% exp.asmr$BGC)%>% data.table
rSMR.exp <- melt(exp.asmr, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMR.exp") %>% 
  mutate(BGC = gsub(" ", "", BGC, fixed = TRUE), variable = gsub("_Exp", "", variable, fixed = TRUE))
rSMR.cmd <- melt(cmd.asmr, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMR.cmd") %>% 
  mutate(variable = gsub("_", "", variable, fixed = TRUE))
aSMRdiff <- left_join(rSMR.cmd, rSMR.exp, by = c("BGC", "variable")) %>% drop_na %>% mutate(asmr.diff = aSMR.cmd - aSMR.exp)
#write.csv(aSMRdiff, "./outputs/Comparison of Modelled aSMR to Expert matrix.csv")
aSMRdiff <-aSMRdiff %>% mutate(not.sig.diff = between(asmr.diff, -0.5, .5)) 
aSMRdiff2 <- aSMRdiff %>% mutate(Zone = gsub("[^A-Z]", "", BGC)) %>% mutate(asmr.diff = as.factor(asmr.diff))%>%
  mutate(not.sig.diff = ifelse(asmr.diff == 0, "zero", not.sig.diff)) %>%
  drop_na()
diffs <- aSMRdiff  %>% count(variable, asmr.diff) %>% mutate(asmr.diff = as.factor(asmr.diff)) %>% 
  pivot_wider(names_from = asmr.diff, values_from = n, values_fill = 0) %>% 
  rename(CMD_difference = variable)


gt::gt(diffs) %>%
  gt::tab_header(
    title = "Count of difference between aSMR from CMD model and Expert aSMR for Zonal Sites",
    subtitle = "CMD aSMR is drier (negative) or wetter (positive) than expert aSMR"
  ) %>%
  gt::tab_options(
    table.font.size = "small",        # options: xx-small to xx-large, or numeric like "80%"
    data_row.padding = gt::px(2),         # tighter spacing between rows
    heading.title.font.size = gt::px(14)  # tweak the title size separately if desired
  )
```

```{r }
#| label: fig-difference-cmd-expert
#| fig-cap: "aSMR Classes from CMD Model compared to expert assessment by Zone"
#| fig-subcap: "CMD is drier (negative) or wetter (positive)"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"
# colnames(rSMRListexp) <- c("BGC", "rSMR", "aSMRE")
# Loop through unique BGC values and generate individual plots
unique_zones <- unique(aSMRdiff2$Zone)

for (zone in unique_zones) {
  # Filter dataset for the current BGC
  aSMRdiff_subset <- aSMRdiff2 %>% filter(Zone == zone)
  
  # Create the histogram
  asmr.plot <- ggplot(aSMRdiff_subset, aes(asmr.diff, fill = not.sig.diff)) +
    geom_bar() +
    facet_wrap(~ variable, nrow = 2) +
    geom_vline(xintercept = 0, colour = "green") +
    xlab("Difference in aSMR Classes") +
    ylab("Count") +
    scale_fill_manual(values = c("zero" = "darkgreen", "TRUE" = "green", "FALSE" = "orange")) +
    theme_hc() +
    ggtitle(paste0("Histogram of aSMR Differences for ", zone))
  plot(asmr.plot)
  # Save each plot as an image file
  #ggsave(filename = paste0("aSMRdiff_", zone, ".png"), plot = plot, width = 8, height = 6)
}
# plot(dr)
# ggsave("./outputs/aSMR difference expert_climate by rSMR.pdf", plot = dr, dpi = "print", device = "pdf", width = 15, height = 15, units = "in")
# dev.off()

```

### ForDrat derived aSMR classes for all BGCs

```{r drought tool aSMR, echo=FALSE, message = FALSE, warning=FALSE}
DRT <- fread("./inputs/DroughtTool_AETxrSMR.csv") %>% filter(Period == "1961-1990") %>%  mutate(rSMR = paste0("rSMR", RSMR)) %>% select(BGC, rSMR, AET)
DRT <- pivot_wider(DRT, id_cols = BGC, names_from = rSMR, values_from = AET)
DRT <- DRT %>% filter(BGC %in% AllBGC)

rules <- read.csv("./inputs/AET_Rules_HalfStep_v12_30Oct2024.csv")

### import rules on range of CMD which equates to aSMR
aSMRClass <- function(x) {
  for (i in seq_along(ruleSelect$AET))  {
    if (i < length(ruleSelect$AET) && x <= ruleSelect$AET[i+1]) {
      return(ruleSelect$aSMR[i])
    }
  }
  return(x)
}

# Initialize an empty data.frame to accumulate results
all_aet <- data.frame()
#i=1
for (i in seq_along(DRT$BGC)) {
  DRT.bgc <- DRT[i,]
  test <- foreach(SMR = colnames(DRT.bgc)[-1], .combine = cbind) %do% {
    temp <- DRT.bgc %>% select(!!as.name(SMR))
    temp[is.na(temp)] <- 0
    ruleSelect <- rules[rules$SMRLevel == 0, -1]
    out <- sapply(temp, FUN = aSMRClass)
    out
  }
  
  bgc <- as.data.frame(test)
  row.names(bgc) <- DRT.bgc$BGC
  colnames(bgc) <- c("rSMR1", "rSMR2", "rSMR3", "rSMR4", "rSMR5")
  
  # Accumulate the test data into all_tests
  all_aet <- rbind(all_aet, bgc)
}
# gt::gt(all_aet,
#        rownames_to_stub = TRUE) %>% 
#   gt::tab_stubhead(label = "BGC") %>%
#   gt::tab_header(
#     title = "aSMR for rSMR by BGC",
#     subtitle = "aSMR classes calculated from Drought Tool AET") %>% 
#     gt::tab_options(
#          column_labels.font.size = 12,
#          column_labels.font.weight = "bold",
#         table.font.size = 12,
#         table.font.weight = "bold")
  all_aet <- all_aet %>% rownames_to_column(var = "BGC")
#saveRDS(all_aet, file = "./outputs/rSMR_aSMR_DroughtModel.rds")
#fwrite(all_aet, file = "./outputs/rSMR_aSMR_DroughtModel.csv")
```

### Difference between ForDrat and the Expert aSMR by BGC

```{r }
#| label: fig-difference-aet-expert
#| fig-cap: "aSMR Classes from ForDrat Model compared to expert assessment"
#| fig-subcap: "ForDrat is drier (negative) or wetter (positive)"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"
exp.asmr <- expGrid %>% filter(BGC %in% all_aet$BGC)%>% data.table
aet.asmr <- all_aet %>% filter(BGC %in% exp.asmr$BGC)%>% data.table

rSMR.exp <- melt(exp.asmr, id.vars = c("BGC"), variable_name = "rSMR", value.name = "aSMR.exp") %>% 
  mutate(BGC = gsub(" ", "", BGC, fixed = TRUE), variable = gsub("_Exp", "", variable, fixed = TRUE))
rSMR.aet <- melt(aet.asmr, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMR.aet") %>% 
  mutate(variable = gsub("_", "", variable, fixed = TRUE))
aSMRdiff <- left_join(rSMR.aet, rSMR.exp, by = c("BGC", "variable")) %>% drop_na %>% mutate(asmr.diff = aSMR.aet - aSMR.exp)
#write.csv(aSMRdiff, "./outputs/Comparison of Modelled aSMR to Expert matrix.csv")
aSMRdiff <-aSMRdiff %>% mutate(not.sig.diff = between(asmr.diff, -0.5, .5)  ) 

aSMRdiff2 <- aSMRdiff %>% mutate(Zone = gsub("[^A-Z]", "", BGC)) %>% mutate(asmr.diff = as.factor(asmr.diff))%>%
  mutate(not.sig.diff = ifelse(asmr.diff == 0, "zero", not.sig.diff)) %>%
  drop_na()
diffs <- aSMRdiff  %>% count(variable, asmr.diff) %>% mutate(asmr.diff = as.factor(asmr.diff)) %>% 
  pivot_wider(names_from = asmr.diff, values_from = n, values_fill = 0) %>% 
  rename(CMD_difference = variable)


gt::gt(diffs) %>%
  gt::tab_header(
    title = "Count of difference between aSMR from ForDrat and Expert aSMR for Zonal Sites",
    subtitle = "ForDrat aSMR is drier (negative) or wetter (positive) than expert aSMR"
  ) %>%
  gt::tab_options(
    table.font.size = "small",        # options: xx-small to xx-large, or numeric like "80%"
    data_row.padding = gt::px(2),         # tighter spacing between rows
    heading.title.font.size = gt::px(14) 
)
#  ggplot(aSMRdiff, aes(asmr.diff, fill = not.sig.diff))+
#   geom_histogram(binwidth = .25 ) +
#   facet_wrap(~ variable, nrow = 2)+
#       geom_vline (xintercept = 0, colour = "green")+
# xlab ("Difference in aSMR Classes")+
#   ylab ("Count")+
#    theme_hc()


```

### Difference between CMD modelled and the AET modelled aSMR by BGC

```{r }
#| label: fig-difference-cmd-aet
#| fig-cap: "aSMR Classes from CMD Model compared to AET model"
#| fig-subcap: "CMD is drier (negative) or wetter (positive)"
#| fig-cap-location: bottom
#| warning: false
#| fig-align: "center"
# asmr_aet <- all_aet %>% filter(BGC %in% all_cmd$BGC)%>% data.table
# asmr_cmd <- all_cmd %>% filter(BGC %in% asmr_aet$BGC)%>% data.table
# rSMR.cmd <- melt(asmr_cmd, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMR.cmd") %>% 
#   mutate(variable = gsub("_", "", variable, fixed = TRUE))
# rSMR.aet <- melt(asmr_aet, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMR.aet") %>% 
#   mutate(BGC = gsub(" ", "", BGC, fixed = TRUE), variable = gsub("_AET", "", variable, fixed = TRUE))
# 
# aSMRdiff <- left_join(rSMR.cmd, rSMR.aet, by = c("BGC", "variable")) %>% mutate(asmr.diff = aSMR.cmd - aSMR.aet)
# #write.csv(aSMRdiff, "./outputs/Comparison of Modelled aSMR to Expert matrix.csv")
# aSMRdiff <-aSMRdiff %>% mutate(not.sig.diff = between(asmr.diff, -0.5, .5)
#   ) 
# #aSMRDiffCount2 <- aggregate(BGC ~ diff, aSMRdiff, length)
# #aSMRdiffmat <- cast(aSMRdiff, diff ~ aSMRC) #ignore message here casts to matrix
#  ggplot(aSMRdiff, aes(asmr.diff, fill = not.sig.diff))+
#   geom_histogram(binwidth = .25 ) +
#   facet_wrap(~ variable, nrow = 2)+
#       geom_vline (xintercept = 0, colour = "green")+
#   xlab ("Difference in aSMR Classes")+
#   ylab ("Count")+
#    theme_hc()

# plot(dr)
# ggsave("./outputs/aSMR difference expert_climate by rSMR.pdf", plot = dr, dpi = "print", device = "pdf", width = 15, height = 15, units = "in")
# dev.off()
```

```{r aSMR byrSMR classes, echo=FALSE, message = FALSE, warning=FALSE}
all_cmd2 <- all_cmd
colnames(all_cmd2 ) <- c("BGC", "rSMR0", "rSMR1", "rSMR2", "rSMR3", "rSMR4", "rSMR5", "rSMR6", "rSMR7")
gt::gt(all_cmd2,
       rownames_to_stub = FALSE) %>% 
  gt::tab_stubhead(label = "BGC") %>%
  gt::tab_header(
    title = "aSMR for rSMR by BGC",
    subtitle = "aSMR classes calculated from CMD values") %>% 
    gt::tab_options(
         column_labels.font.size = 12,
         column_labels.font.weight = "bold",
        table.font.size = 12,
        table.font.weight = "bold")
all_cmd.coast <- all_cmd %>%  filter(grepl("^(CDF|CMA|CWH|MH|IDFww|ICHun|ESSFun1|MSun)", BGC))
fwrite(all_cmd.coast, file = "./outputs/asmr_x_rsmr_Coast.csv")
#all_cmd <- all_cmd %>% rownames_to_column(var = "BGC")
saveRDS(all_cmd, file = "./outputs/rSMR_aSMR_ModelGrid.rds")
fwrite(all_cmd, file = "./outputs/WNAv13_rSMR_aSMR_ModelGrid.csv")
```

### Expert assessed aSMR by rSMR for BGCs

```{r }
#| label: asmr-exprt
#| warning: false
#| tbl-align: "left"
#expGrid <- expGrid %>% filter(grepl('^CWH|^CDF|MH|IDFww|CMA', BGC)) 
gt::gt(expGrid,
       rownames_to_stub = TRUE) %>% 
  gt::tab_stubhead(label = "BGC") %>%
  gt::tab_header(
    title = "aSMR for rSMR by BGC",
    subtitle = "aSMR from expert assessment") %>% 
    gt::tab_options(
         column_labels.font.size = 12,
         column_labels.font.weight = "bold",
        table.font.size = 12,
        table.font.weight = "bold")

#saveRDS(all_cmd, file = "./outputs/rSMR_aSMR_ModelGrid.rds")

```

### Estimated aSMR of relative rSMR positions by BGC

```{r }
#| label: asmr-CMD-model
#| warning: false
#| tbl-align: "left"
#rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v12_1May2025.csv") ### import rules on range of CMD which equates to aSMR
# rules <- read.csv("./inputs/aSMR_Rules_HalfStep_v13_7May2025_2.csv")
# #BGC.rain <- fread("./inputs/Coast_freq_rain_BGCs.csv") %>% filter(freq_rain %in% "y") %>% pull(bgc)
# aSMRClass <- function(x) {
#   for (i in seq_along(ruleSelect$CMD)) {
#     if (i < length(ruleSelect$CMD) && x <= ruleSelect$CMD[i+1]) {
#       return(ruleSelect$aSMR[i])
#     }
#   }
#   return(x)
# }
# 
# # Initialize an empty data.frame to accumulate results
# all_cmd <- data.frame()
# #i=1
# for (i in seq_along(CMD$BGC)) {
#   CMD.bgc <- CMD[i,]
#   test <- foreach(SMR = colnames(CMD.bgc)[-1], .combine = cbind) %do% {
#     temp <- CMD.bgc %>% select(!!as.name(SMR))
#     temp[is.na(temp)] <- 0
#     
#     if (SMR == "rSMR7") {
#       ruleSelect <- rules[rules$SMRLevel == 7, -1]
#     } else if (SMR == "rSMR6") {
#       ruleSelect <- rules[rules$SMRLevel == 6, -1]
#     } else if (SMR == "rSMR5") {
#       ruleSelect <- rules[rules$SMRLevel == 5, -1]
#     } else {
#       ruleSelect <- rules[rules$SMRLevel == 0, -1]
#     }
#     
#     out <- sapply(temp, FUN = aSMRClass)
#     out
#   }
#   
#   bgc <- as.data.frame(test)
#   row.names(bgc) <- CMD.bgc$BGC
#   colnames(bgc) <- c("rSMR_0", "rSMR_1", "rSMR_2", "rSMR_3", "rSMR_4", "rSMR_5", "rSMR_6", "rSMR_7")
#   
#   # Accumulate the test data into all_tests
#   all_cmd <- rbind(all_cmd, bgc)
# }

```

```{r comparative table, echo=FALSE, message = FALSE, warning=FALSE}

# 
# aSMR_rSMR <- cbind(CMD[1], test)
# colnames(aSMR_rSMR) <- c("BGC", "rSMR0", "rSMR1", "rSMR2", "rSMR3", "rSMR4", "rSMR5", "rSMR6", "rSMR7")
# save(aSMR_rSMR,file = "./outputs/rSMR_aSMR_ModelGrid.RData")
# write.csv(aSMR_rSMR, file= "./outputs/modelled_WNAv11_rSMR_aSMR_grid_HalfStep.csv", row.names = FALSE)
# 
# aSMR_rSMR.long <- melt(aSMR_rSMR, id.vars= c("BGC"), variable_name = "rSMR", value.name = "aSMRC")
# colnames(aSMR_rSMR.long) <- c("BGC", "rSMR", "aSMRC")
# save(aSMR_rSMR.long,file = "./outputs/rSMR_aSMR_CalcList.RData")
# SMRwide <- cbind(CMD, test)
# SMRwide$BGC <- gsub("[[:space:]]","",SMRwide$BGC)

#SMRCross <- melt(SMRwide) ###aSMR lookup
#colnames(SMRCross) <- c("BGC", "rSMR", "aSMRC")

#load ("rSMR_aSMR_CalcList.RData")
```
